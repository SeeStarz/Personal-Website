# SeeStarz's Website
Deployment link: <https://seestarz.my.id>
> [!WARNING]
> This README page may be slightly (or worse very) incorrect at times. Making proper documentation is tiring especially when I don't even have proper testing in place. Please report any inconsistencies thank you.

## Table of Contents
- [SeeStarz's Website](#seestarz-s-website)
  * [Some Facts](#some-facts)
  * [Project Hierarchy](#project-hierarchy)
  * [Building](#building)
    + [With nix-shell](#with-nix-shell)
      - [Prerequisites](#prerequisites)
      - [Environment Setup](#environment-setup)
      - [Automatic Rebuild](#automatic-rebuild)
      - [Release Build](#release-build)
    + [Without nix-shell](#without-nix-shell)
      - [Prerequisites](#prerequisites-1)
      - [Environment Setup](#environment-setup-1)
      - [Automatic Rebuild](#automatic-rebuild-1)
      - [Release Build](#release-build-1)
  * [Deploying](#deploying)
  * [Contributing](#contributing)
  * [License](#license)

<small><i><a href='http://ecotrust-canada.github.io/markdown-toc/'>Table of contents generated with markdown-toc</a></i></small>

## Some Facts
Q: Static site?  
A: Yeah, static site. No good reason to make it dynamic just yet. Probably when I integrate some sort of dynamic refresh that does not need manual intervention \(e.g. typeracer stats\).  

Q: Why not `react`?  
A: I'm a JS hater thank you very much.  

~~Q: If you're a JS hater, why use `live-server` and `tailwind`?~~  
~~A: Well it's too annoying to find replacements. At least it's install once forget forever.~~  
Apparently, `live-server` has a rust port and `tailwindcss` has a standalone binary.

Q: Why `jinja2`?  
A: Well, in my uni I was taught `django`.`jinja2` was pretty similar, so why not? Gets the job done.  

Q: Why `nix`?  
A: I've been wanting to use `nix` for a while, it's quite overwhelming but a pretty cool concept. ~~The main reason I use `nix` however, is because `npm` sucks so bad, I don't even get virtual environment. `nix` solves this by providing a consistent and isolated environment.~~ Sunken cost fallacy, I'm already regretting this decision.  

Q: Why not `docker` instead for consistent build environment?  
A: I may have skill issue here, but `apt-get` shenanigans is just weird, it's also slow if you decide to change any of the installs.  

Q: Design page?  
A: It's on figma currently, and you know... it's not exactly shareable ¯\\\_\(ツ\)\_/¯.  

Q: Responsive design when?  
A: L8er.  

Q: Tests?  
A: Bro what can I test T.T, not like I like tests anyways \(f it we ball method\).  

Q: So no CI? Only CD?  
A: Yes. Debug on deployment, as they say.  

## Project Hierarchy
```text
.
├── .git/
├── .github/
├── .gitignore
├── Caddyfile
├── LICENSE.txt
├── Procfile
├── README.md
├── dist/
├── dist.py
├── env/
├── node_modules/
├── package-lock.json
├── package.json
├── requirements.lock
├── shell.nix
└── src
    ├── css
    │   ├── base.css
    │   ├── compiled.css
    │   ├── dark-hc.css
    │   ├── dark-mc.css
    │   ├── dark.css
    │   ├── light-hc.css
    │   ├── light-mc.css
    │   └── light.css
    ├── img/
    ├── templates
    │   ├── components/
    │   └── pages/
    └── ts/
```
Before the project is built, `dist/`, `env/`, `node_modules/` are not present.
- LICENSE.txt contains MIT license text.
- `env/` and `node_modules/` are automatically generated by the respective package manager/virtual environments. \[not tracked by git\]
- `shell.nix` describes required dependencies and environment setup.
- `package.json` lists used npm packages.
- `package-lock.json` contains exact versions of npm packages.
- `requirements.lock` contains exact versions of pip packages.
- `.git` contains git artifacts. \[not tracked by git\]
- `.gitignore` contains directory listings ignored by git.
- `.github` contains github workflows (deploy script as per time of writing).
- `Procfile` contains commands for local development.
- `Caddyfile` contains configuration for deployment.
- `dist.py` contains project build script.
- `src/` contains artifacts needed to develop and build the project.
- `dist/` is the target directory for building the project. \[not tracked by git\]
- `src/css/base.css` contains tailwind import as well as custom defined utilities and themes.
- `src/css/compiled.css` contains resulting tailwind css compilation. \[not tracked by git\]
- `src/css/{dark, dark-hc, dark-mc, light, light-hc, light-mc}.css` contains material design 3 color scheme used in the project.
- `src/img/` contains static images.
- `src/templates/components/` contains jinja2 templates, some specific to a page while some are shared between pages.
- `src/templates/pages/` contains the final page templates.
- `src/ts` contains typescript stuffs (empty as per time of writing).

## Building
### With nix-shell
#### Prerequisites
- nix (mine is version 2.32.2 as time of writing if that is of interest)
- git

#### Environment Setup
```bash
git clone https://github.com/SeeStarz/Personal-Website.git
cd Personal-Website
nix-shell --pure
```

#### Automatic Rebuild
- Inside `nix-shell` run `hivemind Procfile`, this will run 3 separate commands that monitor changes.
- `inotifywait` loop checks for any changes, and redistribute into `dist` directory.
- `tailwind` cli monitors changes in any html file, then creates `src/css/compiled.css` with recipe from `src/css/base.css`.
- `live-server` will serve the pages, and pages will reflect changes without needing a refresh.

#### Release Build
Inside `nix-shell` run `tailwindcss -i src/css/base.css -o src/css/compiled.css -m && ./dist.py`.  
Alternatively, run `nix-shell --pure --run 'tailwindcss -i src/css/base.css -o src/css/compiled.css -m && ./dist.py'`

### Without nix-shell
#### Prerequisites
> [!TIP]
> These are directly taken from `shell.nix`, and version numbers are taken from inside the shell.
> You could possibly get away with slightly different versions, no guarantees though.
- python3 \(3.13.5\)
- pip \(well, not really a prerequisite actually, 25.0.1\)
- jinja2 \(3.1.6\)
- live-server \(From rust's cargo or node's npm whichever is fine, mine is cargo, 0.10.0\)
- tailwindcss \(3.4.17\)
- git \(2.50.1\)
- hivemind \(1.1.0, can be substituted with anything that can read Procfile\)
- inotify-tools \(called the same in arch packages, version missing\)

#### Environment Setup
There's nothing really.

#### Automatic Rebuild
- Run `hivemind Procfile`, this will run 3 separate commands that monitor changes.
- `inotifywait` loop checks for any changes, and redistribute into `dist` directory.
- `tailwind` cli monitors changes in any html file, then creates `src/css/compiled.css` with recipe from `src/css/base.css`.
- `live-server` will serve the pages, and pages will reflect changes without needing a refresh.

#### Release Build
`tailwindcss -i src/css/base.css -o src/css/compiled.css -m && ./dist.py`

## Deploying
- First, build the project as described in [Building](#building)
- Caddy is assumed to have been installed in the target host.
- On `/etc/caddy/Caddyfile` (or wherever caddy config is), include the line `import /etc/caddy/personal/*` (or wherever you want to put caddyfile).
- Make sure `/var/www/personal/` and `/etc/caddy/personal/` (or wherever you decide to put it) has the desired user as the owner.
- Transfer `dist/` to `/var/www/personal` and copy `Caddyfile` into `/etc/caddy/personal/Caddyfile`.
- Example for deployment can be seen in github actions at `.github/workflows/deploy.yml`

## Contributing
Documentation issue? Yeah. Bug tracker? Probably, let me finish first though. Feature request? Mmmmm I don't know.

## License
This project is released under the MIT license. I'm no lawyer, but in plain english:  
Do anything you want, just don't credit derivative work I didn't make under my name.  

Giving credits is always appreciated \(for the original, not derivative works\) but never required.

This project stands on the shoulders of many great pieces of software.  
I can’t list every single one, but their contributions remains important nonetheless.  
Each direct and transitive dependencies remain the property of its respective owner\(s\).
